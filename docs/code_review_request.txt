1) Correctness + edge cases
Ask for:
•	Hidden logic bugs
•	Weird edge cases (empty inputs, huge inputs, timezones, double submits, flaky networks)
•	Race conditions (especially in async UI flows)
Output you want:
•	A list of high-risk paths + how to harden them
2) Readability + maintainability (the “old-school respect” bucket)
Ask for:
•	Clear naming, consistent structure
•	Functions/components that do one thing
•	Low “cleverness per line” (pros prefer boring code that survives)
Output you want:
•	Refactor suggestions that reduce cognitive load
•	A “diff-style” set of edits or PR checklist
3) Architecture + boundaries
Ask for:
•	Separation of concerns (UI vs state vs data fetching vs domain logic)
•	Folder/module boundaries that scale past Phase 1
•	Dependency sanity (no spaghetti imports)
Output you want:
•	A recommended project structure and where each responsibility should live
4) Type safety + runtime validation
If you’re in TypeScript (likely), ask for:
•	Strong types where it matters (API contracts, domain objects)
•	Runtime validation for external input (user input, API responses) so you don’t trust the universe blindly
Output you want:
•	Concrete places to add validation and stricter types
5) Security + privacy (especially because this is interview prep + job platform adjacent)
Ask for:
•	XSS, injection risks, unsafe HTML rendering
•	Auth/session handling assumptions
•	Secrets management
•	PII handling (what you store, log, send)
Output you want:
•	A threat-model-lite: top risks + mitigations
6) Performance + UX performance
Ask for:
•	Avoidable rerenders, heavy components, unnecessary network calls
•	Bundle size and dependency bloat
•	Caching strategy
•	Perceived performance (loading states, optimistic UI)
Output you want:
•	A prioritized list: “fix these 5 things first”
7) Testing strategy (this screams “professional”)
Ask for:
•	Unit tests for pure logic
•	Component tests for key flows
•	E2E for “happy path” + one nasty path
•	Testability refactors (move logic out of UI)
Output you want:
•	A minimum viable test suite plan for Phase 1 integration
8) Observability + operability (the grown-up stuff)
Ask for:
•	Error handling standards
•	Logging (structured, non-PII)
•	Metrics/events you should track (drop-off points, completion rate, failed saves)
•	Feature flags/config
Output you want:
•	“If this breaks in prod, how would we know and how fast can we fix it?”
9) Accessibility + polish
Ask for:
•	Keyboard navigation, focus management, ARIA labels
•	Color contrast
•	Form error messaging
Output you want:
•	An a11y punch list (small fixes, big credibility)
10) Documentation + repo hygiene
Ask for:
•	README that explains setup, scripts, env vars, architecture, and “how to deploy”
•	Consistent formatting/linting/prettier
•	Conventional commits / changelog style (optional but impressive)
Output you want:
•	A “professional repo checklist” to match what real teams expect

